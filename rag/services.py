# rag/services.py
import os
import json
import logging
from typing import List, Dict, Tuple, Optional
from django.conf import settings
from django.db.models import Q
from django.contrib.contenttypes.models import ContentType
from pgvector.django import CosineDistance
import google.generativeai as genai
from openai import OpenAI
from django.utils import timezone

from .models import EmbeddingModel, ChatSession, ChatMessage, RAGAnalytics
from services.models import ServiceCategory, FAQ
from projects.models import Project
from pricing.models import ServicePricing

logger = logging.getLogger(__name__)


class EmbeddingService:
    """–°–µ—Ä–≤—ñ—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —Ç–∞ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è embedding'–∞–º–∏"""
    
    def __init__(self):
        self.gemini_api_key = getattr(settings, 'GEMINI_API_KEY', None)
        self.openai_api_key = getattr(settings, 'OPENAI_API_KEY', None)
        
        # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∑ settings
        self.rag_settings = getattr(settings, 'RAG_SETTINGS', {})
        self.embedding_model = self.rag_settings.get('EMBEDDING_MODEL', 'gemini')
        
        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è AI –∫–ª—ñ—î–Ω—Ç—ñ–≤
        if self.embedding_model == 'gemini' and self.gemini_api_key:
            genai.configure(api_key=self.gemini_api_key)
            
        if self.openai_api_key:
            self.openai_client = OpenAI(api_key=self.openai_api_key)
    
    def generate_embedding(self, text: str, model: str = None) -> List[float]:
        """–ì–µ–Ω–µ—Ä—É—î embedding –¥–ª—è —Ç–µ–∫—Å—Ç—É"""
        if not text.strip():
            raise ValueError("–¢–µ–∫—Å—Ç –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø—É—Å—Ç–∏–º")
            
        model = model or self.embedding_model
        
        try:
            if model == 'gemini':
                return self._generate_gemini_embedding(text)
            elif model == 'openai':
                return self._generate_openai_embedding(text)
            else:
                raise ValueError(f"–ù–µ–≤—ñ–¥–æ–º–∞ –º–æ–¥–µ–ª—å: {model}")
                
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó embedding: {e}")
            raise
    
    def _generate_gemini_embedding(self, text: str) -> List[float]:
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è embedding —á–µ—Ä–µ–∑ Gemini"""
        model = self.rag_settings.get('GEMINI_EMBEDDING_MODEL', 'models/embedding-001')
        
        response = genai.embed_content(
            model=model,
            content=text,
            task_type="retrieval_document"
        )
        
        return response['embedding']
    
    def _generate_openai_embedding(self, text: str) -> List[float]:
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è embedding —á–µ—Ä–µ–∑ OpenAI"""
        model = self.rag_settings.get('OPENAI_EMBEDDING_MODEL', 'text-embedding-3-small')
        
        response = self.openai_client.embeddings.create(
            model=model,
            input=text
        )
        
        return response.data[0].embedding
    
    def create_embedding_for_object(self, obj, language: str = 'uk') -> EmbeddingModel:
        """–°—Ç–≤–æ—Ä—é—î embedding –¥–ª—è Django –æ–±'—î–∫—Ç–∞"""
        content_type = ContentType.objects.get_for_model(obj)
        
        # –í–∏—Ç—è–≥—É—î–º–æ —Ç–µ–∫—Å—Ç –∑ –æ–±'—î–∫—Ç–∞
        text_content = self._extract_text_from_object(obj, language)
        title = self._extract_title_from_object(obj, language)
        category = self._extract_category_from_object(obj)
        
        if not text_content:
            logger.warning(f"–ù–µ–º–∞—î —Ç–µ–∫—Å—Ç—É –¥–ª—è —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó: {obj}")
            return None
        
        # –ì–µ–Ω–µ—Ä—É—î–º–æ embedding
        try:
            embedding_vector = self.generate_embedding(text_content)
        except Exception as e:
            logger.error(f"–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ embedding –¥–ª—è {obj}: {e}")
            raise
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∞–±–æ –æ–Ω–æ–≤–ª—é—î–º–æ
        embedding_obj, created = EmbeddingModel.objects.update_or_create(
            content_type=content_type,
            object_id=obj.pk,
            language=language,
            defaults={
                'embedding': embedding_vector,
                'content_text': text_content[:5000],  # –û–±–º–µ–∂—É—î–º–æ –¥–æ–≤–∂–∏–Ω—É
                'content_title': title,
                'content_category': category,
                'model_name': f"{self.embedding_model}-embedding",
                'is_active': True,
            }
        )
        
        action = "—Å—Ç–≤–æ—Ä–µ–Ω–æ" if created else "–æ–Ω–æ–≤–ª–µ–Ω–æ"
        logger.info(f"Embedding {action} –¥–ª—è {obj} ({language})")
        
        return embedding_obj
    
    def _extract_text_from_object(self, obj, language: str) -> str:
        """–í–∏—Ç—è–≥—É—î —Ç–µ–∫—Å—Ç –∑ Django –æ–±'—î–∫—Ç–∞ –¥–ª—è —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó"""
        text_parts = []
        
        if isinstance(obj, ServiceCategory):
            title = getattr(obj, f'title_{language}', obj.title_en)
            description = getattr(obj, f'description_{language}', obj.description_en)
            short_desc = getattr(obj, f'short_description_{language}', obj.short_description_en)
            target_audience = getattr(obj, f'target_audience_{language}', obj.target_audience_en)
            value_prop = getattr(obj, f'value_proposition_{language}', obj.value_proposition_en)
            
            if title: text_parts.append(f"–°–µ—Ä–≤—ñ—Å: {title}")
            if description: text_parts.append(description)
            if short_desc: text_parts.append(short_desc)
            if target_audience: text_parts.append(f"–î–ª—è –∫–æ–≥–æ: {target_audience}")
            if value_prop: text_parts.append(f"–ü–µ—Ä–µ–≤–∞–≥–∏: {value_prop}")
            
        elif isinstance(obj, Project):
            title = getattr(obj, f'title_{language}', obj.title_en)
            short_desc = getattr(obj, f'short_description_{language}', obj.short_description_en)
            client_request = getattr(obj, f'client_request_{language}', obj.client_request_en)
            implementation = getattr(obj, f'implementation_{language}', obj.implementation_en)
            results = getattr(obj, f'results_{language}', obj.results_en)
            
            if title: text_parts.append(f"–ü—Ä–æ—î–∫—Ç: {title}")
            if short_desc: text_parts.append(short_desc)
            if client_request: text_parts.append(f"–ó–∞–≤–¥–∞–Ω–Ω—è: {client_request}")
            if implementation: text_parts.append(f"–†—ñ—à–µ–Ω–Ω—è: {implementation}")
            if results: text_parts.append(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {results}")
            
        elif isinstance(obj, FAQ):
            question = getattr(obj, f'question_{language}', obj.question_en)
            answer = getattr(obj, f'answer_{language}', obj.answer_en)
            
            if question: text_parts.append(f"–ü–∏—Ç–∞–Ω–Ω—è: {question}")
            if answer: text_parts.append(f"–í—ñ–¥–ø–æ–≤—ñ–¥—å: {answer}")
        
        elif isinstance(obj, ServicePricing):
            # üí∞ –í–∏—Ç—è–≥—É—î–º–æ –¥–∞–Ω—ñ –ø—Ä–æ —Ü—ñ–Ω–∏
            package_name = getattr(obj, f'package_name_{language}', obj.package_name_en)
            description = getattr(obj, f'description_{language}', obj.description_en)
            features = getattr(obj, f'features_{language}', obj.features_en)
            
            text_parts.append(f"–¢–∞—Ä–∏—Ñ–Ω–∏–π –ø–ª–∞–Ω: {package_name} –¥–ª—è –ø–æ—Å–ª—É–≥–∏ {obj.service.title}")
            text_parts.append(f"–¶—ñ–Ω–∞: {obj.price} {obj.currency}")
            text_parts.append(f"–û–ø–∏—Å: {description}")
            if features:
                text_parts.append(f"–©–æ –≤—Ö–æ–¥–∏—Ç—å: {', '.join(features)}")
        
        return '\n'.join(text_parts)
    
    def _extract_title_from_object(self, obj, language: str) -> str:
        """–í–∏—Ç—è–≥—É—î –∑–∞–≥–æ–ª–æ–≤–æ–∫ –æ–±'—î–∫—Ç–∞"""
        if hasattr(obj, f'title_{language}'):
            return getattr(obj, f'title_{language}') or getattr(obj, 'title_en', str(obj))
        elif hasattr(obj, f'question_{language}'):  # FAQ
            return getattr(obj, f'question_{language}') or getattr(obj, 'question_en', str(obj))
        return str(obj)
    
    def _extract_category_from_object(self, obj) -> str:
        """–í–∏—Ç—è–≥—É—î –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –æ–±'—î–∫—Ç–∞"""
        if isinstance(obj, ServiceCategory):
            return 'service'
        elif isinstance(obj, Project):
            return 'project'
        elif isinstance(obj, FAQ):
            return 'faq'
        elif isinstance(obj, ServicePricing):
            return 'pricing'
        return 'unknown'


class VectorSearchService:
    """–°–µ—Ä–≤—ñ—Å –¥–ª—è –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ—à—É–∫—É"""
    
    def __init__(self):
        self.embedding_service = EmbeddingService()
        self.rag_settings = getattr(settings, 'RAG_SETTINGS', {})
        
    def search_similar_content(
        self, 
        query: str, 
        language: str = 'uk',
        limit: int = None,
        category: str = None,
        threshold: float = None
    ) -> List[Dict]:
        """–®—É–∫–∞—î —Å—Ö–æ–∂–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ—à—É–∫—É"""
        
        limit = limit or self.rag_settings.get('MAX_SEARCH_RESULTS', 10)
        threshold = threshold or self.rag_settings.get('SIMILARITY_THRESHOLD', 0.7)
        
        # –ì–µ–Ω–µ—Ä—É—î–º–æ embedding –¥–ª—è –∑–∞–ø–∏—Ç—É
        try:
            query_embedding = self.embedding_service.generate_embedding(query)
        except Exception as e:
            logger.error(f"–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ embedding –¥–ª—è –∑–∞–ø–∏—Ç—É '{query}': {e}")
            return []
        
        # –ë—É–¥—É—î–º–æ –∑–∞–ø–∏—Ç –¥–æ –ë–î
        queryset = EmbeddingModel.objects.filter(
            is_active=True,
            language=language
        )
        
        if category:
            queryset = queryset.filter(content_category=category)
        
        # –í–µ–∫—Ç–æ—Ä–Ω–∏–π –ø–æ—à—É–∫ –∑ cosine distance
        results = queryset.annotate(
            distance=CosineDistance('embedding', query_embedding)
        ).filter(
            distance__lt=(1 - threshold)  # Cosine distance: –º–µ–Ω—à–µ = —Å—Ö–æ–∂—ñ—à–µ
        ).order_by('distance')[:limit]
        
        # –§–æ—Ä–º–∞—Ç—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
        formatted_results = self._serialize_search_results(results)
        
        logger.info(f"Vector search –¥–ª—è '{query}': –∑–Ω–∞–π–¥–µ–Ω–æ {len(formatted_results)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤")
        return formatted_results

    def _serialize_search_results(self, results: List[EmbeddingModel]) -> List[Dict]:
        """–°–µ—Ä—ñ–∞–ª—ñ–∑—É—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ—à—É–∫—É –≤ JSON-—Å—É–º—ñ—Å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç."""
        serialized_results = []
        for result in results:
            obj = result.content_object
            if not obj:
                continue
            
            data = {
                'content_text': result.content_text,
                'content_title': result.content_title,
                'content_category': result.content_category,
                'similarity': round(1 - float(result.distance), 3),
                'metadata': result.metadata,
                'model_info': {
                    'app_label': result.content_type.app_label,
                    'model_name': result.content_type.model,
                    'pk': obj.pk,
                }
            }

            if hasattr(obj, 'get_absolute_url'):
                try:
                    data['url'] = obj.get_absolute_url()
                except Exception:
                    data['url'] = None
            
            if hasattr(obj, 'slug'):
                data['slug'] = obj.slug

            # –î–æ–¥–∞—î–º–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–≤–∞–Ω—ñ –ø–æ–ª—è –¥–ª—è –ø—Ä–∞–π—Å–∏–Ω–≥—É (ServicePricing)
            if result.content_type.app_label == 'pricing' and result.content_type.model == 'servicepricing':
                try:
                    data['price_from'] = float(getattr(obj, 'price_from', 0) or 0)
                    data['price_to'] = float(getattr(obj, 'price_to', 0) or 0) if getattr(obj, 'price_to', None) else None
                    data['currency'] = 'USD'
                    service_category = getattr(obj, 'service_category', None)
                    data['service_title'] = getattr(service_category, 'title_en', str(service_category)) if service_category else None
                    tier = getattr(obj, 'tier', None)
                    data['package_name'] = getattr(tier, 'display_name_en', str(tier)) if tier else None
                except Exception:
                    pass

            serialized_results.append(data)
        
        return serialized_results


class RAGConsultantService:
    """–ì–æ–ª–æ–≤–Ω–∏–π RAG –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç"""
    
    def __init__(self):
        self.vector_search = VectorSearchService()
        self.embedding_service = EmbeddingService()
        self.rag_settings = getattr(settings, 'RAG_SETTINGS', {})
        
        # AI –∫–ª—ñ—î–Ω—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π
        self.gemini_api_key = getattr(settings, 'GEMINI_API_KEY', None)
        if self.gemini_api_key:
            genai.configure(api_key=self.gemini_api_key)

    def _contains_pricing_keywords(self, text: str) -> bool:
        t = (text or '').lower()
        return any(w in t for w in ['—Ü—ñ–Ω–∞', '–∫–æ—à—Ç—É—î', '–±—é–¥–∂–µ—Ç', 'price', '–≤–∞—Ä—Ç—ñ—Å—Ç—å'])
    
    def process_user_query(
        self, 
        query: str, 
        session_id: str,
        language: str = 'uk'
    ) -> Dict:
        """–û–±—Ä–æ–±–ª—è—î –∑–∞–ø–∏—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —á–µ—Ä–µ–∑ RAG"""
        
        # –û—Ç—Ä–∏–º—É—î–º–æ –∞–±–æ —Å—Ç–≤–æ—Ä—é—î–º–æ —Å–µ—Å—ñ—é
        session, created = ChatSession.objects.get_or_create(
            session_id=session_id,
            defaults={'detected_intent': 'general'}
        )

        # –î—ñ—Å—Ç–∞—î–º–æ –º–µ—Ç–∞–¥–∞–Ω—ñ —Å–µ—Å—ñ—ó
        meta = getattr(session, 'metadata', {}) or {}
        clar_asked = bool(meta.get('clarification_asked', False))
        
        # –í–µ–∫—Ç–æ—Ä–Ω–∏–π –ø–æ—à—É–∫ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç—É
        search_results = self.vector_search.search_similar_content(
            query=query,
            language=language,
            limit=5
        )
        
        # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –Ω–∞–º—ñ—Ä –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        detected_intent = self._detect_user_intent(query, search_results)

        # –ö–µ—Ä—É–≤–∞–Ω–Ω—è pricing-—Å—Ç–∞–Ω–æ–º —á–µ—Ä–µ–∑ metadata, –±–µ–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ "–∑–∞–ª–∏–ø–∞–Ω–Ω—è"
        meta = getattr(session, 'metadata', {}) or {}
        awaiting = bool(meta.get('awaiting_pricing_details', False))
        completed = bool(meta.get('pricing_completed', False))

        if self._contains_pricing_keywords(query):
            detected_intent = 'pricing'
        elif awaiting and not completed:
            detected_intent = 'pricing'

        session.detected_intent = detected_intent
        session.total_messages += 1
        
        # –í–∏–∑–Ω–∞—á–∞—î–º–æ, —á–∏ —Ü–µ —Ñ–æ–ª–ª–æ—É–∞–ø (–ø—ñ—Å–ª—è –ø–µ—Ä—à–æ–≥–æ –ø–∏—Ç–∞–Ω–Ω—è –∞—Å–∏—Å—Ç–µ–Ω—Ç–∞)
        recent_msgs = list(session.messages.order_by('-created_at')[:4])
        is_followup = any(m.role == 'assistant' for m in recent_msgs)

        # –ñ–æ—Ä—Å—Ç–∫–æ –æ–±–º–µ–∂—É—î–º–æ —É—Ç–æ—á–Ω–µ–Ω–Ω—è –æ–¥–Ω–∏–º –∑–∞—Ö–æ–¥–æ–º –¥–ª—è pricing
        if detected_intent == 'pricing':
            allow_ask = (not clar_asked) and (not is_followup)
        else:
            allow_ask = False

        # –ì–µ–Ω–µ—Ä—É—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å
        response = self._generate_rag_response(
            query=query,
            search_results=search_results,
            language=language,
            intent=detected_intent,
            chat_history=session.messages.order_by('-created_at')[:4],
            is_followup=is_followup,
            allow_ask=allow_ask
        )

        # –ì–∞—Ä–∞–Ω—Ç—ñ—è –ø–æ–∫–∞–∑—É –∫–Ω–æ–ø–∫–∏ –ø—Ä–æ—Ä–∞—Ö—É–Ω–∫—É –ø—Ä–∏ —Ç–µ–∫—Å—Ç–æ–≤–∏—Ö –æ–∑–Ω–∞–∫–∞—Ö —Ü—ñ–Ω
        try:
            resp_text = (response.get('content') or '').lower()
            has_textual_price = any(
                key in resp_text for key in ['–æ—Ä—ñ—î–Ω—Ç–æ–≤–Ω', '–≤–∞—Ä—Ç—ñ—Å—Ç', 'price', 'usd', '$']
            )
            if has_textual_price and not response.get('prices_ready', False):
                response['prices_ready'] = True
            if response.get('prices_ready'):
                actions = list(response.get('actions', []))
                has_quote_btn = any(
                    (a.get('type') == 'button' and a.get('action') == 'request_quote') for a in actions
                )
                if not has_quote_btn:
                    actions.append({
                        'type': 'button',
                        'text': 'üßÆ –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω–∏–π –ø—Ä–æ—Ä–∞—Ö—É–Ω–æ–∫ —É PDF',
                        'action': 'request_quote',
                        'style': 'primary'
                    })
                response['actions'] = actions
        except Exception:
            pass

        # –Ø–∫—â–æ –º–∏ —â–æ–π–Ω–æ –∑–∞–¥–∞–ª–∏ —É—Ç–æ—á–Ω–µ–Ω–Ω—è –¥–ª—è –ø—Ä–∞–π—Å–∏–Ω–≥—É ‚Äî –≤—ñ–¥–º—ñ—á–∞—î–º–æ –≤ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
        if detected_intent == 'pricing' and allow_ask:
            meta['clarification_asked'] = True
        
        # –û–Ω–æ–≤–ª—é—î–º–æ metadata —Å—Ç–∞–Ω –¥–ª—è pricing (–æ–¥–Ω–æ—Ä–∞–∑–æ–≤–µ —É—Ç–æ—á–Ω–µ–Ω–Ω—è ‚Üí –æ—á—ñ–∫—É—î–º–æ; –∫–æ–ª–∏ —Ü—ñ–Ω–∏ –≥–æ—Ç–æ–≤—ñ ‚Üí –∑–∞–≤–µ—Ä—à—É—î–º–æ)
        resp = response
        if detected_intent == 'pricing' and allow_ask:
            meta['awaiting_pricing_details'] = True
        if detected_intent == 'pricing' and bool(resp.get('prices_ready')):
            meta['pricing_completed'] = True
            meta['awaiting_pricing_details'] = False

        session.metadata = meta
        session.save()
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        ChatMessage.objects.create(
            session=session,
            role='user',
            content=query
        )
        
        ChatMessage.objects.create(
            session=session,
            role='assistant', 
            content=response['content'],
            rag_sources_used=[r['content_title'] for r in search_results],
            vector_search_results=search_results,
            ai_model_used='gemini-pro'
        )
        
        return {
            'response': response['content'],
            'intent': detected_intent,
            'sources': search_results,
            'suggestions': response.get('suggestions', []),
            'actions': response.get('actions', []),
            'prices_ready': response.get('prices_ready', False),
            'session_id': session_id
        }
    
    def _detect_user_intent(self, query: str, search_results: List[Dict]) -> str:
        """–í–∏–∑–Ω–∞—á–∞—î –Ω–∞–º—ñ—Ä –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        query_lower = query.lower()
        
        # –ö–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –Ω–∞–º—ñ—Ä—É
        if any(word in query_lower for word in ['—Ü—ñ–Ω–∞', '—Å–∫—ñ–ª—å–∫–∏', '–∫–æ—à—Ç—É—î', '–±—é–¥–∂–µ—Ç', 'price']):
            return 'pricing'
        elif any(word in query_lower for word in ['–∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—è', '–∑—É—Å—Ç—Ä—ñ—á', '–ø–æ–≥–æ–≤–æ—Ä–∏—Ç–∏', 'consultation']):
            return 'consultation'
        elif any(word in query_lower for word in ['–ø—Ä–æ—î–∫—Ç', '–ø–æ—Ä—Ç—Ñ–æ–ª—ñ–æ', '–∫–µ–π—Å', '–ø—Ä–∏–∫–ª–∞–¥', 'project']):
            return 'portfolio'
        elif search_results and search_results[0]['content_category'] == 'service':
            return 'services'
        else:
            return 'general'
    
    def _generate_rag_response(
        self, 
        query: str, 
        search_results: List[Dict],
        language: str,
        intent: str,
        chat_history: List[ChatMessage],
        is_followup: bool,
        allow_ask: bool
    ) -> Dict:
        """–ì–µ–Ω–µ—Ä—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞ –æ—Å–Ω–æ–≤—ñ RAG –∫–æ–Ω—Ç–µ–∫—Å—Ç—É"""
        
        if not search_results:
            return self._generate_fallback_response(query, language, intent)
        
        # –ë—É–¥—É—î–º–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç –∑ –Ω–∞–π–∫—Ä–∞—â–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        context_parts = []
        for result in search_results[:3]:  # –¢–æ–ø 3 —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
            context_parts.append(f"""
–î–∂–µ—Ä–µ–ª–æ: {result['content_title']} (—Å—Ö–æ–∂—ñ—Å—Ç—å: {result['similarity']})
–¢–∏–ø: {result['content_category']}
–ö–æ–Ω—Ç–µ–Ω—Ç: {result['content_text'][:800]}
""")
        
        context = "\n---\n".join(context_parts)
        
        # –§–æ—Ä–º—É—î–º–æ —ñ—Å—Ç–æ—Ä—ñ—é —á–∞—Ç—É –¥–ª—è –ø—Ä–æ–º–ø—Ç–∞
        history_text = ""
        if chat_history:
            history_lines = []
            for msg in reversed(chat_history):
                role = "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á" if msg.role == 'user' else "–ê—Å–∏—Å—Ç–µ–Ω—Ç"
                history_lines.append(f"{role}: {msg.content}")
            history_text = "\n".join(history_lines)

        # –ü—Ä–∞–≤–∏–ª–æ: –∂–æ—Ä—Å—Ç–∫–∏–π –∫–æ—Ä–æ—Ç–∫–∏–π —Ñ–ª–æ—É –¥–ª—è pricing
        pricing_flow_mode = (intent == 'pricing')

        system_prompt = self._get_system_prompt(
            language,
            intent,
            is_first_message=(not history_text),
            is_followup=is_followup
        )

        if intent == 'pricing' and not is_followup:
            if allow_ask:
                system_prompt += "\n–í–∞–∂–ª–∏–≤–æ: —Ü–µ —î–¥–∏–Ω–∞ —Å–µ—Ä—ñ—è —É—Ç–æ—á–Ω–µ–Ω—å —É –≤—Å—ñ–π —Å–µ—Å—ñ—ó."
            else:
                system_prompt += "\n–ù–µ —Å—Ç–∞–≤ –Ω—ñ—è–∫–∏—Ö —É—Ç–æ—á–Ω–µ–Ω—å, –æ–¥—Ä–∞–∑—É –ø–µ—Ä–µ—Ö–æ–¥—å –¥–æ –æ—Ü—ñ–Ω–æ–∫."
        
        user_prompt = f"""
–ü–æ–ø–µ—Ä–µ–¥–Ω—è —Ä–æ–∑–º–æ–≤–∞:
{history_text}

–ö–æ–Ω—Ç–µ–∫—Å—Ç:
{context}

–ó–∞–ø–∏—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {query}

–î–∞–π –≤—ñ–¥–ø–æ–≤—ñ–¥—å —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é –Ω–∞ –æ—Å–Ω–æ–≤—ñ –Ω–∞–¥–∞–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É —Ç–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—ó —Ä–æ–∑–º–æ–≤–∏.
"""
        
        try:
            model = genai.GenerativeModel('gemini-1.5-pro-latest')
            response = model.generate_content(
                f"{system_prompt}\n\n{user_prompt}",
                generation_config=genai.types.GenerationConfig(
                    temperature=0.7,
                    max_output_tokens=1000,
                )
            )
            
            ai_response = response.text

            prices_ready = False
            prices = []
            # –Ø–∫—â–æ pricing —ñ —Ü–µ —Ñ–æ–ª–ª–æ—É–∞–ø ‚Äî –¥–æ–¥–∞—î–º–æ/–ø—ñ–¥—Å–∏–ª—é—î–º–æ —Ü—ñ–Ω–∏ (–±–µ–∑ –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö –ø–∏—Ç–∞–Ω—å)
            if pricing_flow_mode and is_followup:
                pricing_lines = []
                for r in search_results:
                    if r.get('content_category') == 'pricing':
                        price_from = r.get('price_from')
                        price_to = r.get('price_to')
                        currency = r.get('currency', '')
                        pkg = r.get('package_name') or r.get('content_title')
                        service_title = r.get('service_title')
                        price_str = None
                        if price_from is not None and price_to is not None:
                            price_str = f"{price_from}-{price_to} {currency}".strip()
                        elif price_from is not None:
                            price_str = f"–≤—ñ–¥ {price_from} {currency}".strip()
                        elif price_to is not None:
                            price_str = f"–¥–æ {price_to} {currency}".strip()
                        if (price_from is not None or price_to is not None) and pkg:
                            prices.append({
                                'title': f"{pkg}{f' ({service_title})' if service_title else ''}",
                                'description': '',
                                'price_from': price_from if price_from is not None else '',
                                'price_to': price_to if price_to is not None else '',
                                'currency': currency
                            })
                        if price_str and pkg:
                            line = f"- {pkg}: {price_str}"
                            if service_title:
                                line = f"{line} ({service_title})"
                            pricing_lines.append(line)
                pricing_lines = list(dict.fromkeys(pricing_lines))[:5]
                if pricing_lines:
                    prices_ready = True
                    if '–¶—ñ–Ω–∏' not in ai_response:
                        ai_response = ai_response.strip() + "\n\n–¶—ñ–Ω–∏ (–æ—Ä—ñ—î–Ω—Ç–æ–≤–Ω–æ):\n" + "\n".join(pricing_lines)

            # –†–µ–∑–µ—Ä–≤–Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ –±–∞–∑–æ–≤–∏—Ö —Ü—ñ–Ω –∑–∞ —Ç–µ–∫—Å—Ç–æ–º –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ
            if not prices_ready:
                resp_lower = (ai_response or '').lower()
                if ('–æ—Ä—ñ—î–Ω—Ç–æ–≤–Ω' in resp_lower) or ('$' in ai_response) or ('usd' in resp_lower) or ('–≤–∞—Ä—Ç—ñ—Å—Ç' in resp_lower) or ('price' in resp_lower):
                    prices_ready = True

            # –û–¥–Ω–æ—Ä–∞–∑–æ–≤–∞ –∑–≥–∞–¥–∫–∞ GDPR —É –ø–µ—Ä—à—ñ–π –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤ —Å–µ—Å—ñ—ó
            is_first_assistant_reply = True
            if chat_history:
                for m in chat_history:
                    if m.role == 'assistant':
                        is_first_assistant_reply = False
                        break
            if is_first_assistant_reply:
                ai_response = ai_response.strip() + "\n\n–¶–µ –≥–∞—Ä–∞–Ω—Ç—É—î –∫–æ–Ω—Ñ—ñ–¥–µ–Ω—Ü—ñ–π–Ω—ñ—Å—Ç—å —Ç–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º GDPR."

            # –î—ñ—ó (CTA)
            actions = []
            consult_url = self.rag_settings.get('CONSULTATION_URL') or self.rag_settings.get('CONSULTATION_CALENDAR_URL')
            if consult_url:
                actions.append({
                    'type': 'link',
                    'text': '–ó–∞–ø–∏—Å–∞—Ç–∏—Å—è –Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—é',
                    'url': consult_url,
                    'style': 'secondary',
                    'persistent': True
                })
            if prices_ready:
                actions.append({
                    'type': 'button',
                    'text': 'üßÆ –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω–∏–π –ø—Ä–æ—Ä–∞—Ö—É–Ω–æ–∫ —É PDF',
                    'action': 'request_quote',
                    'style': 'primary'
                })
            
            suggestions = self._generate_suggestions(intent, search_results, language)
            
            return {
                'content': ai_response,
                'suggestions': suggestions,
                'context_used': len(search_results),
                'prices_ready': prices_ready,
                'actions': actions,
                'prices': prices
            }
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó RAG –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ: {e}")
            return self._generate_fallback_response(query, language, intent)
    
    def _get_system_prompt(self, language: str, intent: str, is_first_message: bool, is_followup: bool) -> str:
        """–ü–æ–≤–µ—Ä—Ç–∞—î —Å–∏—Å—Ç–µ–º–Ω–∏–π –ø—Ä–æ–º–ø—Ç –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –Ω–∞–º—ñ—Ä—É"""
        
        consultant_name = self.rag_settings.get('CONSULTANT_NAME', '–Æ–ª—ñ—è')
        
        # üöÄ –î–∏–Ω–∞–º—ñ—á–Ω–∞ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è
        intro_instruction = f"–ü—Ä–µ–¥—Å—Ç–∞–≤—Å—è —è–∫ {consultant_name}, –¥–æ—Å–≤—ñ–¥—á–µ–Ω–∞ IT –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç–∫–∞ –∫–æ–º–ø–∞–Ω—ñ—ó LazySoft, —ñ –ø—Ä–∏–≤—ñ—Ç–∞–π—Å—è." if is_first_message else ""
 
        # –ü—Ä–∞–≤–∏–ª–∞ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–æ–≥–æ —Ñ–ª–æ—É —Ü—ñ–Ω–æ—É—Ç–≤–æ—Ä–µ–Ω–Ω—è
        pricing_flow = ""
        if intent == 'pricing':
            if not is_followup:
                pricing_flow = (
                    "–ü—ñ—Å–ª—è –ø—Ä–∏–≤—ñ—Ç–∞–Ω–Ω—è –∑–∞–¥–∞–π –û–î–ò–ù —Ä–∞–∑ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–≤–Ω–∏–π –ø–µ—Ä–µ–ª—ñ–∫ —É—Ç–æ—á–Ω–µ–Ω—å –¥–ª—è –æ—Ü—ñ–Ω–∫–∏, "
                    "—É —Ñ–æ—Ä–º–∞—Ç—ñ –Ω—É–º–µ—Ä–æ–≤–∞–Ω–æ–≥–æ —Å–ø–∏—Å–∫—É (1., 2., 3., 4.,5.), –Ω–µ –±—ñ–ª—å—à–µ 5 –ø—É–Ω–∫—Ç—ñ–≤. "
                    "–ù–µ –ø—É–±–ª—ñ–∫—É–π —Ü—ñ–Ω–∏ —É —Ü—å–æ–º—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—ñ."
                )
            else:
                pricing_flow = (
                    "–¶–µ —Ñ–æ–ª–ª–æ—É–∞–ø: –Ω–µ —Å—Ç–∞–≤ –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö –ø–∏—Ç–∞–Ω—å. –î–∞–π —Ü—ñ–Ω–∏ –æ–¥—Ä–∞–∑—É –ø—ñ—Å–ª—è —É—Ç–æ—á–Ω–µ–Ω—å, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π –Ω–∞—è–≤–Ω—ñ –ø—Ä–∞–π—Å–∏; "
                    "—è–∫—â–æ –±—Ä–∞–∫—É—î –¥–∞–Ω–∏—Ö, –∑—Ä–æ–±–∏ –∫–æ—Ä–æ—Ç–∫—ñ –ø—Ä–∏–ø—É—â–µ–Ω–Ω—è (–≤ –¥—É–∂–∫–∞—Ö) —ñ –Ω–∞–≤–µ–¥–∏ –¥—ñ–∞–ø–∞–∑–æ–Ω–∏."
                )
        
        base_prompt = f"""
{intro_instruction}
–¢–∏ –¥–æ–ø–æ–º–∞–≥–∞—î—à –∫–ª—ñ—î–Ω—Ç–∞–º –∑ —Ç–µ—Ö–Ω—ñ—á–Ω–∏–º–∏ —Ä—ñ—à–µ–Ω–Ω—è–º–∏ —Ç–∞ –±—ñ–∑–Ω–µ—Å-–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—î—é.

–¢–≤–æ—è –ø–æ–≤–µ–¥—ñ–Ω–∫–∞:
- –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–æ, –∞–ª–µ –¥—Ä—É–∂–µ–ª—é–±–Ω–æ. –ù–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–π—Å—è, —è–∫—â–æ —Ü–µ –Ω–µ –ø–µ—Ä—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è.
- –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ —Ñ–∞–∫—Ç–∏ –∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É —Ç–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—ó —Ä–æ–∑–º–æ–≤–∏.
- –ü—Ä–æ–ø–æ–Ω—É–π –ø—Ä–∞–∫—Ç–∏—á–Ω—ñ —Ä—ñ—à–µ–Ω–Ω—è.
- –ó–∞–≤–∂–¥–∏ –∑–≥–∞–¥—É–π —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ñ –ø—Ä–æ—î–∫—Ç–∏ –∞–±–æ —Å–µ—Ä–≤—ñ—Å–∏.
- –ù–µ –∑–≥–∞–¥—É–π –ø–æ—Ö–æ–¥–∂–µ–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó —Ç–∞ –Ω–µ –ø–∏—à–∏ —Ñ—Ä–∞–∑–∏ –Ω–∞ –∫—à—Ç–∞–ª—Ç "–∑ –Ω–∞—à–æ—ó –±–∞–∑–∏ –∑–Ω–∞–Ω—å".
- –Ø–∫—â–æ –∑–∞–ø–∏—Ç –ø–æ—Ç—Ä–µ–±—É—î —É—Ç–æ—á–Ω–µ–Ω—å, –∑–∞–¥–∞–π —ó—Ö —è–∫ –Ω—É–º–µ—Ä–æ–≤–∞–Ω–∏–π —Å–ø–∏—Å–æ–∫ (1., 2., 3., 4., 5.), –∞–ª–µ —Ç—ñ–ª—å–∫–∏ 1 —Ä–∞–∑, –ø—ñ—Å–ª—è –¥–∞–≤–∞–π —Ü—ñ–Ω–∏
- –ù–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π Markdown-—Ä–æ–∑–º—ñ—Ç–∫—É (–±–µ–∑ **, –±–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫—ñ–≤, –±–µ–∑ —Å–ø–∏—Å–∫—ñ–≤ Markdown).
- –ü—Ä–æ–ø–æ–Ω—É–π –∑–∞–ø–∏—Å–∞—Ç–∏—Å—è –Ω–∞ –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω—É –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—é –∞–±–æ –ø—Ä–æ—Ä–∞—Ö—É–Ω–æ–∫
- –Ø–∫—â–æ –≤ —Ç–µ–±–µ –Ω–µ–º–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –Ω–∞ –ø–∏—Ç–∞–Ω–Ω—è, —Å–∫–∞–∂–∏ —â–æ —Ç–∏ –Ω–∞–∂–∞–ª—å –Ω–µ –∫–æ–º–ø–µ–Ω–µ—Ç–Ω–∞ —ñ –∑–∞–ø—Ä–æ–ø–æ–Ω—É–π –∑–∞–ø–∏—Å–∞—Ç–∏—Å—è –Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—é
{pricing_flow}
"""
        
        intent_prompts = {
            'pricing': f"""
{base_prompt}
–§–æ–∫—É—Å –Ω–∞ —Ü—ñ–Ω–∏: –ö–æ–ª–∏ –≥–æ–≤–æ—Ä–∏—à –ø—Ä–æ —Ü—ñ–Ω–∏, –∑–∞–≤–∂–¥–∏:
1. –£—Ç–æ—á–Ω—é–π –¥–µ—Ç–∞–ª—ñ –ø—Ä–æ—î–∫—Ç—É –ø–µ—Ä–µ–¥ –Ω–∞–∑–∏–≤–∞–Ω–Ω—è–º —Ü—ñ–Ω –æ–¥–∏–Ω —Ä–∞–∑
2. –ü—Ä–æ–ø–æ–Ω—É–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ –ø–∞–∫–µ—Ç–∏ (–±–∞–∑–æ–≤–∏–π/—Å—Ç–∞–Ω–¥–∞—Ä—Ç/–ø—Ä–µ–º—ñ—É–º)
3. –ó–≥–∞–¥—É–π –ø—Ä–∏–∫–ª–∞–¥–∏ —Å—Ö–æ–∂–∏—Ö –ø—Ä–æ—î–∫—Ç—ñ–≤
4. –ü—Ä–æ–ø–æ–Ω—É–π –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω—É –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—é –∞–±–æ –ø—Ä–æ—Ä–∞—Ö—É–Ω–æ–∫
""",
            'consultation': f"""
{base_prompt}
–§–æ–∫—É—Å –Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—ó: 
1. –ü—ñ–¥–∫—Ä–µ—Å–ª—é–π –ø–µ—Ä–µ–≤–∞–≥–∏ –æ—Å–æ–±–∏—Å—Ç–æ–≥–æ —Å–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è
2. –ü—Ä–æ–ø–æ–Ω—É–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ —á–∞—Å–∏ –¥–ª—è –∑—É—Å—Ç—Ä—ñ—á—ñ
3. –ì–æ—Ç—É–π —Å–ø–∏—Å–æ–∫ –ø–∏—Ç–∞–Ω—å –¥–ª—è –∫—Ä–∞—â–æ—ó –ø—ñ–¥–≥–æ—Ç–æ–≤–∫–∏
""",
            'services': f"""
{base_prompt}
–§–æ–∫—É—Å –Ω–∞ —Å–µ—Ä–≤—ñ—Å–∏:
1. –î–µ—Ç–∞–ª—å–Ω–æ —Ä–æ–∑–ø–æ–≤—ñ–¥–∞–π –ø—Ä–æ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ
2. –ù–∞–≤–æ–¥—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ –ø—Ä–∏–∫–ª–∞–¥–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è  
3. –ü—Ä–æ–ø–æ–Ω—É–π —Å—É–ø—É—Ç–Ω—ñ –ø–æ—Å–ª—É–≥–∏
""",
            'portfolio': f"""
{base_prompt}
–§–æ–∫—É—Å –Ω–∞ –ø—Ä–æ—î–∫—Ç–∏:
1. –†–æ–∑–ø–æ–≤—ñ–¥–∞–π –ø—Ä–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ –∫–µ–π—Å–∏
2. –ü—ñ–¥–∫—Ä–µ—Å–ª—é–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Ç–∞ ROI
3. –ü—Ä–æ–ø–æ–Ω—É–π —Å—Ö–æ–∂—ñ —Ä—ñ—à–µ–Ω–Ω—è
""",
        }
        
        return intent_prompts.get(intent, base_prompt)
    
    def _generate_suggestions(self, intent: str, search_results: List[Dict], language: str) -> List[str]:
        """–ì–µ–Ω–µ—Ä—É—î –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó"""
        
        suggestions = []
        
        if intent == 'pricing':
            suggestions = [
                "üìÖ –ó–∞–ø–∏—Å–∞—Ç–∏—Å—è –Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—é"
            ]
        elif intent == 'consultation':
            suggestions = [
                "üìÖ –û–±—Ä–∞—Ç–∏ –∑—Ä—É—á–Ω–∏–π —á–∞—Å –¥–ª—è –∑—É—Å—Ç—Ä—ñ—á—ñ",
                "üìù –ü—ñ–¥–≥–æ—Ç—É–≤–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –ø–∏—Ç–∞–Ω—å",
                "üíº –†–æ–∑–ø–æ–≤—ñ—Å—Ç–∏ –ø—Ä–æ –≤–∞—à –±—ñ–∑–Ω–µ—Å",
            ]
        
         
        
        return suggestions
    
    def _generate_fallback_response(self, query: str, language: str, intent: str) -> Dict:
        """–ì–µ–Ω–µ—Ä—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å –∫–æ–ª–∏ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç—É"""
        
        fallback_responses = {
            'uk': {
                'pricing': "–©–æ–± –¥–∞—Ç–∏ —Ç–æ—á–Ω—É —Ü—ñ–Ω—É, –º–µ–Ω—ñ –ø–æ—Ç—Ä—ñ–±–Ω–æ –±—ñ–ª—å—à–µ –¥–µ—Ç–∞–ª–µ–π –ø—Ä–æ –≤–∞—à –ø—Ä–æ—î–∫—Ç. –†–æ–∑–∫–∞–∂—ñ—Ç—å, –±—É–¥—å –ª–∞—Å–∫–∞, —â–æ —Å–∞–º–µ –≤–∞—Å —Ü—ñ–∫–∞–≤–∏—Ç—å?",
                'consultation': "–Ø –±—É–¥—É —Ä–∞–¥–∞ –æ–±–≥–æ–≤–æ—Ä–∏—Ç–∏ –≤–∞—à–µ –ø–∏—Ç–∞–Ω–Ω—è –Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü—ñ—ó. –ö–æ–ª–∏ –≤–∞–º –±—É–¥–µ –∑—Ä—É—á–Ω–æ –∑—É—Å—Ç—Ä—ñ—Ç–∏—Å—è?",
                'services': "–†–æ–∑–∫–∞–∂—ñ—Ç—å –±—ñ–ª—å—à–µ –ø—Ä–æ —Ç–µ, —â–æ –≤–∞—Å —Ü—ñ–∫–∞–≤–∏—Ç—å, —ñ —è –∑–º–æ–∂—É –∑–∞–ø—Ä–æ–ø–æ–Ω—É–≤–∞—Ç–∏ –Ω–∞–π–∫—Ä–∞—â–µ —Ä—ñ—à–µ–Ω–Ω—è.",
                'general': "–¶—ñ–∫–∞–≤–µ –ø–∏—Ç–∞–Ω–Ω—è! –©–æ–± –¥–∞—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –∫–æ—Ä–∏—Å–Ω—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å, —É—Ç–æ—á–Ω—ñ—Ç—å, –±—É–¥—å –ª–∞—Å–∫–∞, –¥–µ—Ç–∞–ª—ñ."
            }
        }
        
        response_text = fallback_responses.get(language, fallback_responses['uk']).get(intent, fallback_responses['uk']['general'])
        
        return {
            'content': response_text,
            'suggestions': [
                "üí¨ –£—Ç–æ—á–Ω–∏—Ç–∏ –ø–∏—Ç–∞–Ω–Ω—è",
                "üìû –ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç–æ–º", 
                "üìã –ü–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –Ω–∞—à—ñ —Å–µ—Ä–≤—ñ—Å–∏"
            ],
            'context_used': 0
        }


class IndexingService:
    """–°–µ—Ä–≤—ñ—Å –¥–ª—è —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó –∫–æ–Ω—Ç–µ–Ω—Ç—É"""
    
    def __init__(self):
        self.embedding_service = EmbeddingService()
        self.rag_settings = getattr(settings, 'RAG_SETTINGS', {})
    
    def index_all_content(self):
        """–Ü–Ω–¥–µ–∫—Å—É—î –≤–µ—Å—å –∫–æ–Ω—Ç–µ–Ω—Ç –∑ –≤–∏–∑–Ω–∞—á–µ–Ω–∏—Ö –º–æ–¥–µ–ª–µ–π"""
        
        indexable_models = self.rag_settings.get('INDEXABLE_MODELS', [])
        languages = self.rag_settings.get('SUPPORTED_LANGUAGES', ['uk'])
        
        total_indexed = 0
        
        for model_path in indexable_models:
            try:
                app_label, model_name = model_path.split('.')
                content_type = ContentType.objects.get(app_label=app_label, model=model_name.lower())
                model_class = content_type.model_class()
                
                objects = model_class.objects.filter(is_active=True) if hasattr(model_class, 'is_active') else model_class.objects.all()
                
                for obj in objects:
                    for lang in languages:
                        try:
                            self.embedding_service.create_embedding_for_object(obj, lang)
                            total_indexed += 1
                        except Exception as e:
                            logger.error(f"–ü–æ–º–∏–ª–∫–∞ —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó {obj} ({lang}): {e}")
                            continue
                            
                logger.info(f"–Ü–Ω–¥–µ–∫—Å–æ–≤–∞–Ω–æ {objects.count()} –æ–±'—î–∫—Ç—ñ–≤ –∑ {model_path}")
                
            except Exception as e:
                logger.error(f"–ü–æ–º–∏–ª–∫–∞ —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó –º–æ–¥–µ–ª—ñ {model_path}: {e}")
                continue
        
        logger.info(f"–ó–∞–≥–∞–ª–æ–º –ø—Ä–æ—ñ–Ω–¥–µ–∫—Å–æ–≤–∞–Ω–æ {total_indexed} –∑–∞–ø–∏—Å—ñ–≤")
        return total_indexed
    
    def reindex_object(self, obj):
        """–ü–µ—Ä–µ—ñ–Ω–¥–µ–∫—Å—É—î –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –æ–±'—î–∫—Ç"""
        languages = self.rag_settings.get('SUPPORTED_LANGUAGES', ['uk'])
        
        for lang in languages:
            try:
                self.embedding_service.create_embedding_for_object(obj, lang)
            except Exception as e:
                logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ—ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó {obj} ({lang}): {e}")
    
    def cleanup_orphaned_embeddings(self):
        """–í–∏–¥–∞–ª—è—î embedding'–∏ –¥–ª—è –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –æ–±'—î–∫—Ç—ñ–≤"""
        deleted_count = 0
        
        for embedding in EmbeddingModel.objects.all():
            if not embedding.content_object:  # –û–±'—î–∫—Ç –≤–∏–¥–∞–ª–µ–Ω–æ
                embedding.delete()
                deleted_count += 1
        
        logger.info(f"–í–∏–¥–∞–ª–µ–Ω–æ {deleted_count} –∑–∞—Å—Ç–∞—Ä—ñ–ª–∏—Ö embedding'—ñ–≤")
        return deleted_count